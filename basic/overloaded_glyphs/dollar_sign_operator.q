/ 
 Three approaches are used to cast from one type to another (except for string) −

	Specify desired data type by its symbol name
	Specify desired data type by its character
	Specify desired data type by it short value.
Casting Integers to Floats
In the following example of casting integers to floats, all the three different ways of casting are equivalent −
q)a:9 18 27

q)$[`float;a]     / Specify desired data type by its symbol name, 1st way
9 18 27f

q)$["f";a]        / Specify desired data type by its character, 2nd way
9 18 27f

q)$[9h;a]         / Specify desired data type by its short value, 3rd way
9 18 27f

\

show "========cast ============="

b: ("Hello";"World";"HelloWorld")    / define a list of strings

show b
/"Hello"
/"World"
/"HelloWorld"

c: `$b                               / this is how to cast strings to symbols
show c                                    / Now c is a list of symbols


show "=======Execution Control (evaluation)=========="
show "Control flow constructs in this section involve branching in the byte code generated by the q interpreter. 
 The offset of the branch destination is limited (currently to 255 byte codes), which means that the sequence of q expressions that can be contained in any part of $, ?, if, do, or while must be short. At some point, insertion of one additional statement will break the camel’s back, resulting in a 'branch error. This is q's way of rejecting bloated code. 
 In this situation, factor code blocks into separate functions. Better yet, restructure your code."
 


$[1b;42;9*6]
/42
$[0b;42;9*6]

show "scope, The brackets in any q conditional do not create lexical scope. This means that variables created within the body exist in the same scope as the conditional. For example, in a fresh q session the variable a in the following is a global that persists outside the conditional."
a:`a

$[1b;a:42;a:43]
/42
show a
/42


show "eager or not, Although evaluation of function arguments in q is eager, evaluation of the expressions in the conditional is short circuited, meaning that only the one selected for return is evaluated. Again in a fresh q session,"
d:`b
show d
$[1b;a:42;d:43]
/42
show a
/42
show d
/`b

v:0N
$[v;`isnull;`notnull]
/ `isnull
$[null v;`isnull;`notnull]


show "========dot product, Matrix Multiply, mmu============"
a:2 4#2 4 8 3 5 6 0 7f
b:4 3#"f"$til 12
a mmu b
/87 104 121
/81 99  117

c:3 3#2 4 8 3 5 6 0 7 1f
1=c mmu inv c
/100b
/010b
/001b

(1 2 3f;4 5 6f)$(7 8f;9 10f;11 12f)
/58  64
/139 154

1 2 3f$4 5 6f  /dot product of two vectors
/32f

1 2 3f $ 1 2 3f
/14f


show "============ enumeration ============"
/
 https://code.kx.com/q4m3/7_Transforming_Data/#75-enumerations
 Enumerations
 We have seen that the binary Cast operator $ transforms its right operand into a conforming entity of the type specified by the left operand. In the basic Cast form, the left operand can be a char type abbreviation, a type short, or a symbol type name.
 In this section, casting is extended to user-defined target domains, providing a functional version of enumerated types.
\
u:`g`aapl`msft`ibm
show u
v:100?u
show v

show "=======$ Pad============"
/
/ x$y    $[x;y]
\

9$"foo"
-9$"foo"

\\